---
Title: 'Design: protobuf event payloads + websocket bridge for 0030'
Ticket: 0030-CARDPUTER-CONSOLE-EVENTBUS
Status: complete
Topics:
    - cardputer
    - keyboard
    - console
    - esp-idf
    - esp32s3
    - display
    - esp-event
    - ui
DocType: design-doc
Intent: long-term
Owners: []
RelatedFiles:
    - Path: 0029-mock-zigbee-http-hub/main/hub_http.c
      Note: Reference for esp_http_server + WebSocket plumbing patterns.
    - Path: 0030-cardputer-console-eventbus/main/app_main.cpp
      Note: Defines the current bus IDs and fixed-size payload structs that the protobuf schema will mirror.
ExternalSources: []
Summary: ""
LastUpdated: 2026-01-05T08:40:38.530213909-05:00
WhatFor: ""
WhenToUse: ""
---


# Design: protobuf event payloads + WebSocket bridge for 0030

## Executive Summary

This design introduces a `.proto` schema for the `0030-cardputer-console-eventbus` event bus and uses standard protobuf tooling to serialize events for forwarding (e.g. over WebSocket), while keeping the internal `esp_event` bus fast and POD-friendly.

Recommended path:

- Keep internal bus payloads as **fixed-size C structs** (as they are today).
- Add a **bridge** that subscribes to bus events and emits a **protobuf envelope** over WebSocket (binary frames).
- Generate TypeScript types/decoders from the same `.proto` so web clients share the schema.

This uses **nanopb** on the device (small embedded-focused protobuf implementation), and a TypeScript codegen decoder on the client.

## Problem Statement

`0030` defines event IDs and payloads directly in C++:

- `/home/manuel/workspaces/2025-12-21/echo-base-documentation/esp32-s3-m5/0030-cardputer-console-eventbus/main/app_main.cpp`

That is great for embedded correctness and performance, but it becomes painful as soon as we want external tooling:

- A WebSocket/SSE client needs the same payload types in TypeScript.
- Without an IDL, we risk drift between embedded structs and host/UI definitions.
- Each new event requires hand-written bridge code and hand-written TS types.

We want a **single source of truth** for event payloads that supports:

- embedded producers/consumers
- WebSocket clients
- future tooling (schema/version checks, dumps, replay)

## Proposed Solution

### 1) Define a bus schema in protobuf

Add a `.proto` file for the 0030 bus, for example:

- `0030-cardputer-console-eventbus/main/idl/demo_bus.proto` (new)

Schema shape:

- `enum EventId` with stable numeric IDs.
- `message` per payload type.
- `message Event` envelope containing `EventId id` + `oneof payload` (+ optional `schema_version`).

Sketch:

```proto
syntax = "proto3";
package demo.bus.v1;

enum EventId {
  EVENT_ID_UNSPECIFIED = 0;
  EVENT_ID_KB_KEY = 1;
  EVENT_ID_KB_ACTION = 2;
  EVENT_ID_CONSOLE_POST = 3;
  EVENT_ID_HEARTBEAT = 4;
  EVENT_ID_RAND = 5;
}

message KbKey { int64 ts_us = 1; uint32 keynum = 2; uint32 modifiers = 3; }
message Heartbeat { int64 ts_us = 1; uint32 heap_free = 2; uint32 dma_free = 3; }
message ConsolePost { int64 ts_us = 1; string msg = 2; }

message Event {
  uint32 schema_version = 1; // e.g. 1
  EventId id = 2;
  oneof payload {
    KbKey kb_key = 10;
    Heartbeat heartbeat = 11;
    ConsolePost console_post = 12;
  }
}
```

### 2) Use nanopb to encode the envelope on-device

Targeted usage:

- Embedded runtime: nanopb runtime (`pb_encode.h` / `pb_decode.h`)
- Codegen: nanopb generator (via `protoc` plugin or generator script)

Encoding (bridge side) looks like:

```c
#include "pb_encode.h"
#include "demo_bus.pb.h"  // generated by nanopb

uint8_t buf[256];
pb_ostream_t stream = pb_ostream_from_buffer(buf, sizeof(buf));

demo_bus_v1_Event ev = demo_bus_v1_Event_init_default;
ev.schema_version = 1;
ev.id = demo_bus_v1_EventId_EVENT_ID_HEARTBEAT;

ev.which_payload = demo_bus_v1_Event_heartbeat_tag;
ev.payload.heartbeat.ts_us = ts_us;
ev.payload.heartbeat.heap_free = heap;
ev.payload.heartbeat.dma_free = dma;

if (!pb_encode(&stream, demo_bus_v1_Event_fields, &ev)) {
  // handle stream.errmsg
}
size_t n = stream.bytes_written;
```

### 3) Bridge bus events to WebSocket binary frames

Add a module that:

- registers an `esp_event` handler for `CARDPUTER_BUS_EVENT, ESP_EVENT_ANY_ID`
- translates `BUS_EVT_*` payload structs into protobuf payload messages
- packs the envelope into a bounded buffer
- sends binary frames to all connected WS clients (or enqueues to a WS sender task)

This keeps internal bus payloads POD/fixed-size, which is ideal for `esp_event_post_to()`.

### 4) Generate TypeScript types/decoders from the same `.proto`

On the web side, decode WebSocket binary frames using a TS protobuf runtime.

Two viable approaches:

- `protobufjs` (load `.proto` at runtime; fast iteration)
- codegen (`ts-proto`, protobufjs static module, etc.; better type safety/perf)

## Design Decisions

### Keep internal bus payloads as fixed-size structs (recommended)

Rationale:

- `esp_event_post_to()` copies raw bytes; fixed-size structs are ideal.
- Protobuf message structs (nanopb/protobuf-c) are not a good fit as direct `esp_event` payloads; keep protobuf for boundary serialization.

### Encode to protobuf at the boundary (WS), not as the in-bus representation

Rationale:

- Keeps event handlers fast and predictable.
- Avoids forcing decode in all internal consumers.
- Lets us keep smooth UI updates in the “UI dispatches the loop” pattern.

### Use nanopb on the device

Rationale:

- nanopb is designed for embedded constraints (small code size, predictable memory when configured).
- It can generate fixed-size arrays for strings/repeated fields (when you provide bounds), avoiding heap allocation.

## Alternatives Considered

### Alternative A: “protobuf everywhere” (bus payload is packed protobuf bytes)

Structure:

- All posts use either a single `BUS_EVT_PROTO` or keep IDs but payload is:
  - `{ uint16_t len; uint8_t bytes[MAX]; }`
- Producers pack protobuf and post bytes.
- Consumers decode bytes to access fields.

Pros:
- One representation everywhere; forwarding is trivial.

Cons:
- More CPU overhead (encode/decode) and RAM for buffers.
- Requires enforcing a `MAX` payload size and handling “too large” events.
- Handlers lose trivial field access unless they decode.

### Alternative B: protobuf-c

Pros:
- Can be convenient if you only need encoding at the boundary and you already have the component.

Cons:
- Decoder side commonly involves heap allocation unless you provide a custom allocator; less “bounded by construction” than nanopb.

## Implementation Plan

1) Add `main/idl/demo_bus.proto` for the 0030 bus.
2) Decide whether generated files are checked in (recommended initially).
3) Add a generator script:
   - `0030-cardputer-console-eventbus/scripts/gen_proto.sh` running nanopb generation (one of):
     - `protoc --nanopb_out=... --proto_path=... demo_bus.proto` (requires `protoc-gen-nanopb` in `PATH`)
     - or run nanopb’s `nanopb_generator.py` directly (no protoc plugin needed; still needs `protoc` for descriptors)
   - In the `.proto`, use nanopb options to bound fields so generated structs are fixed-size (recommended for embedded):
     - `string msg = 2 [(nanopb).max_length = 96];`
     - `repeated uint32 keynums = 3 [(nanopb).max_count = 8];`
4) Update firmware build:
   - Add a vendored `nanopb` component (runtime) to the project (e.g. `components/nanopb/`)
   - Compile generated `demo_bus.pb.c` and include generated headers
5) Add `esp_http_server` WS endpoint (reuse patterns from `0029-mock-zigbee-http-hub`).
6) Add a bus→protobuf→WS bridge module and enable it behind a Kconfig flag.
7) Add a minimal web client and TS decoder driven by the same `.proto` (codegen approach).

## Open Questions

1) **TypeScript codegen choice**
   - We want codegen; the remaining decision is *which* generator/runtime (e.g. `ts-proto` vs protobufjs static module) and how you want it wired into the web build.

2) **Generated code policy**
   - Commit generated `.pb-c.c/.h` and TS outputs to the repo (reproducible builds without generator deps), or generate in CI (cleaner tree but requires toolchain setup in CI)?

## References

- Current demo bus implementation:
  - `/home/manuel/workspaces/2025-12-21/echo-base-documentation/esp32-s3-m5/0030-cardputer-console-eventbus/main/app_main.cpp`
- Proto-as-IDL (format-agnostic) discussion:
  - `ttmp/2026/01/05/0030-CARDPUTER-CONSOLE-EVENTBUS--cardputer-keyboard-esp-console-esp-event-on-screen-event-log/analysis/03-idl-idea-protobuf-defined-esp-event-payloads-not-necessarily-protobuf-wire.md`
